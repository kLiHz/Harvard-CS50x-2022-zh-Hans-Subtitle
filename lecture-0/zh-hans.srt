1
00:01:18,809 --> 00:01:21,339
好, 欢迎来到 CS50

2
00:01:21,339 --> 00:01:25,179
这是哈佛大学针对计算机科学领域所包含的广泛知识

4
00:01:25,179 --> 00:01:26,509
以及编程之艺术的入门介绍课程

5
00:01:26,509 --> 00:01:31,009
经过了这么长时间, 这是我们首次重回校园, 回到这个漂亮的桑德斯剧院

7
00:01:31,110 --> 00:01:33,539
总之, 欢迎大家来到这个课堂

8
00:01:33,580 --> 00:01:35,740
我是大卫·马兰, 又一次来上这门课

9
00:01:44,610 --> 00:01:45,809
我的名字是大卫·马兰

10
00:01:45,809 --> 00:01:48,279
我本人一段时间之前也上过这门课

11
00:01:48,279 --> 00:01:49,679
但是差点

12
00:01:49,779 --> 00:01:51,080
那是大二的秋天

13
00:01:51,080 --> 00:01:52,679
我当时只是在旁听这门课

14
00:01:52,679 --> 00:01:53,910
我只是对这门课感到有些好奇

15
00:01:54,480 --> 00:01:57,210
但是并不觉得这个领域很适合我

16
00:01:57,210 --> 00:01:58,679
我确实是个喜欢用电脑的人

17
00:01:58,679 --> 00:02:00,710
但是计算机科学给我的感觉像是一个很宏大的东西

18
00:02:00,880 --> 00:02:02,410
而我最终鼓起勇气选了这门课

19
00:02:02,410 --> 00:02:04,509
则是因为当时的教授

20
00:02:04,509 --> 00:02:05,479
布莱恩·克尼汉

21
00:02:05,539 --> 00:02:08,140
允许我以不计分, 只记通过与否的方式修读这门课

23
00:02:08,140 --> 00:02:10,080
而这正是造成一切不同的原因

24
00:02:10,110 --> 00:02:11,409
我很快发现

25
00:02:11,409 --> 00:02:15,340
计算机科学并不只是有关自顾自地在电脑上进行编程和工作

27
00:02:15,340 --> 00:02:17,810
更普遍地说, 它其实更注重于问题的解决

28
00:02:17,940 --> 00:02:21,810
坦率来说, 当时的作业真是很有趣来着

30
00:02:21,810 --> 00:02:22,980
也许是我 19 年来第一次这么觉得

31
00:02:22,980 --> 00:02:28,710
还有一路下来, 我和课上所有同学一起探索得到的这种能力

34
00:02:28,710 --> 00:02:32,880
让我能够切实创造出一些东西, 让计算机 "活" 起来, 解决实际的问题

36
00:02:33,080 --> 00:02:35,680
以及从某种程度上能够驾驭一些我曾经每天都在使用

38
00:02:35,680 --> 00:02:37,010
但一直以来并不怎么清楚该如何去利用的东西

39
00:02:37,140 --> 00:02:38,780
收获这种能力让我感到很是受用

40
00:02:38,810 --> 00:02:43,510
诚然, 一路走来, 也少不了挑战性和挫败感, 未来很多年也会如此

42
00:02:43,540 --> 00:02:45,010
你会遇到错误

43
00:02:45,010 --> 00:02:46,580
也就是编程中所说的 bug

44
00:02:46,580 --> 00:02:47,680
它会让你发疯

45
00:02:47,680 --> 00:02:49,080
然后你觉得自己碰了壁

46
00:02:49,310 --> 00:02:52,310
但其实只要给自己足够的时间, 或者退一步往回看看

48
00:02:52,310 --> 00:02:53,680
然后想休息了就休息一下, 问题便迎刃而解

49
00:02:53,710 --> 00:02:55,310
而且我敢说, 没有什么能比得上

50
00:02:55,310 --> 00:02:59,180
当你成功让一些东西工作起来的时候的那种满足感和自豪感

52
00:02:59,180 --> 00:03:02,080
以及在像这样的课堂上, 当学期最终结束时

53
00:03:02,180 --> 00:03:04,710
由你自己亲手完成的最终项目

54
00:03:04,810 --> 00:03:08,010
这并不是说我当时百分之百完美地上完了这门课

55
00:03:08,010 --> 00:03:10,510
事实上就在上周

57
00:03:10,510 --> 00:03:12,810
我翻看了我当时上 CS50 时用的旧活页资料夹

58
00:03:12,810 --> 00:03:15,080
都是 25 年前的了, 但是我现在还保留着它

59
00:03:15,110 --> 00:03:20,510
然后给这个很明显是我第一个所写并提交的

62
00:03:20,580 --> 00:03:22,780
然后很快得了 -2 分的程序拍了张照

63
00:03:22,980 --> 00:03:25,710
但这是一个我们未来几天内很快就会看到的程序

65
00:03:25,710 --> 00:03:29,610
它做了些诸如打印 "Hello, CS50" 这样很简单的事情

67
00:03:29,780 --> 00:03:31,110
在本例中, (就是打印) 到 (计算机) 屏幕上

68
00:03:31,110 --> 00:03:33,580
公平地讲, 我当时确实没有完全按照指导去做

70
00:03:33,580 --> 00:03:35,080
所以我才丢了那两分

71
00:03:35,080 --> 00:03:36,310
但如果你就单看这个

72
00:03:36,580 --> 00:03:38,580
特别是如果你以前从未编程过

73
00:03:38,580 --> 00:03:40,380
你或许听说过编程语言

74
00:03:40,380 --> 00:03:42,110
但你从来没有键入过这样的东西

75
00:03:42,180 --> 00:03:44,110
毫无疑问, 这看起来晦涩难懂

76
00:03:44,310 --> 00:03:46,980
但坦白说, 它并不像人类语言那样

77
00:03:47,080 --> 00:03:51,680
人类语言复杂得多, 有着多得多的词汇, 以及多得多的语法规则

79
00:03:51,810 --> 00:03:55,110
编程这个东西, 一旦你开始理解它究竟是什么, 它是如何工作的

81
00:03:55,110 --> 00:03:56,540
以及这些各式各样的编程语言究竟为何之后

82
00:03:56,540 --> 00:04:02,410
接下来再自学其它语言将会是那么容易, 上几个月这样的课之后你就能发现

86
00:04:02,410 --> 00:04:05,140
在你未来几年的课程中或许就会遇到它们

87
00:04:05,510 --> 00:04:08,610
所以, 在这门课最重要的

88
00:04:08,610 --> 00:04:11,340
不是你最终达到的水平相对于你的同学怎么样

90
00:04:11,380 --> 00:04:13,310
而是相比于你自己刚开始时的情况如何

91
00:04:13,610 --> 00:04:15,810
实际上你们从今天就要开始了

92
00:04:15,810 --> 00:04:19,409
在这门课中, 最终下来, 唯一有意义的经历, 是你自己的经历

94
00:04:19,510 --> 00:04:21,539
所以不妨先想想你今天是怎样的一个情况

95
00:04:21,680 --> 00:04:25,409
不妨想想, 这些东西几秒前看起来还是那么晦涩难懂

98
00:04:25,510 --> 00:04:31,310
而几个月后, 所有这些将尽在你的掌握之中, 是不是感到很欣慰

101
00:04:31,310 --> 00:04:32,580
你当然可能觉得

102
00:04:32,580 --> 00:04:35,280
自己前面, 左面, 右面, 后面的某人

104
00:04:35,280 --> 00:04:36,210
知道的比你多

105
00:04:36,409 --> 00:04:37,940
其实从数据上来看, 并非如此

106
00:04:38,140 --> 00:04:41,979
CS50 课上 2/3 的学生以前从未上过计算机科学的课程

107
00:04:41,979 --> 00:04:46,810
也就是说整个学期下来, 有很多人都和你一样

109
00:04:47,479 --> 00:04:49,380
那么什么是计算机科学呢?

110
00:04:49,380 --> 00:04:50,979
我个人认为它就是在研究如何解决问题

111
00:04:50,979 --> 00:04:55,810
这样就带来一个好处, 因为解决问题几乎是一件我们无时无刻都在做的事情

113
00:04:55,909 --> 00:04:58,310
但是修读计算机科学课, 学习如何编程,

114
00:04:58,310 --> 00:05:00,010
我觉得能一定程度上帮助你理清思绪

116
00:05:00,010 --> 00:05:02,479
它帮助你学会, 如何更有条理地

117
00:05:02,609 --> 00:05:05,140
更细致, 更正确, 更精确地思考

118
00:05:05,140 --> 00:05:05,710
因为老实说

119
00:05:05,710 --> 00:05:07,210
计算机不会执行你想要它做的事

120
00:05:07,210 --> 00:05:10,210
除非你是正确的, 精确的, 有条理的

121
00:05:10,310 --> 00:05:11,210
可见

122
00:05:11,210 --> 00:05:13,479
只是学着像计算科学家和程序员一样思考

124
00:05:13,479 --> 00:05:15,310
就有这么一些附带的好处

126
00:05:15,510 --> 00:05:18,180
而且开始这样做并不需要很多

127
00:05:18,210 --> 00:05:21,810
例如，这可能是个最简单的能描绘计算机科学的图

129
00:05:21,810 --> 00:05:23,739
但事实上任何解决问题的方法也大多如此

130
00:05:23,739 --> 00:05:25,680
问题无非是关乎接受输入

131
00:05:25,680 --> 00:05:27,080
例如一个你想解决的问题

132
00:05:27,109 --> 00:05:29,680
你想要得到解，也就是输出 (output)

133
00:05:29,680 --> 00:05:32,010
所以一些有趣的事情需要发生在这里

134
00:05:32,010 --> 00:05:33,080
以及在这里 (头脑中)

135
00:05:33,109 --> 00:05:35,510
当你试图从这些输入得到输出时

136
00:05:35,940 --> 00:05:38,380
而在计算机这个领域

137
00:05:38,409 --> 00:05:39,510
我们需要事先决定好

138
00:05:39,510 --> 00:05:42,310
要如何表示这些输入和输出

139
00:05:42,310 --> 00:05:46,539
我们要使用一些共同的语言

141
00:05:46,539 --> 00:05:48,010
不管 (这些设备) 是 Mac 还是 PC 还是手机还是别的什么

142
00:05:48,109 --> 00:05:51,340
当然, 也不管我们讲的是什么人类语言

144
00:05:51,409 --> 00:05:53,080
你可能已经知道

145
00:05:53,479 --> 00:05:56,180
计算机只倾向于说哪种语言呢

146
00:05:56,210 --> 00:05:57,180
也就是我们说的

147
00:05:59,310 --> 00:05:59,940
汇编语言

148
00:05:59,940 --> 00:06:02,609
但是其实你说 "二进制" 也没问题

149
00:06:02,609 --> 00:06:05,280
在 "二进制 (binary)" 中, "二 (bi)" 意味着在计算机的世界里

150
00:06:05,380 --> 00:06:07,380
只有 0 和 1 两个数位可供使用

151
00:06:07,510 --> 00:06:11,780
诚然, 我们人类能使用的数字比这更多

152
00:06:11,780 --> 00:06:13,280
至少不只是 0 和 1

153
00:06:13,280 --> 00:06:15,680
但是计算机只有 0 和 1

154
00:06:15,680 --> 00:06:16,710
然而不知何故

155
00:06:16,909 --> 00:06:17,909
它们却可以做到非常多的功能

156
00:06:17,909 --> 00:06:20,310
它们可以处理数字, Excel 表格, 还有文本讯息

157
00:06:20,310 --> 00:06:21,380
也可以生成图像

158
00:06:21,539 --> 00:06:23,479
甚至是艺术作品和电影等等

159
00:06:23,710 --> 00:06:27,409
所以你是如何从一堆 0 和 1 这样简单的东西

161
00:06:27,409 --> 00:06:31,539
得到我们现今在掌中、笔记本电脑和台式机上所做的一切

163
00:06:31,680 --> 00:06:34,180
事实证明，我们可以很简单地开始

164
00:06:34,210 --> 00:06:37,710
如果一台计算机想要做像计数一样简单的事情

166
00:06:37,979 --> 00:06:40,340
它可以怎么做呢? 在我们人类的世界中

167
00:06:40,340 --> 00:06:43,710
我们可以像 "1 2 3 4 5" 这样数

168
00:06:43,739 --> 00:06:45,539
使用所谓的 "一进制计数法"

169
00:06:45,539 --> 00:06:47,010
字面上来说就是, 你手上的每个手指

170
00:06:47,010 --> 00:06:49,109
都是一个数字, 代表房间里的一个人

171
00:06:49,109 --> 00:06:51,080
比方说, 现在我要统计出勤情况

172
00:06:51,180 --> 00:06:53,409
我们人类通常会直接去数

173
00:06:53,680 --> 00:06:55,180
1 2 3 4 5 6

174
00:06:55,180 --> 00:06:58,080
然后我们将会超出这 (一只手所能代表的) 5 个数

176
00:06:58,080 --> 00:06:59,609
并使用从 0 到 9 这些数字, 数到很远的地方

177
00:06:59,609 --> 00:07:02,280
但是计算机却只有 0 和 1

178
00:07:02,539 --> 00:07:05,810
所以如果一台计算机只能使用二进制的 0 和 1

180
00:07:05,810 --> 00:07:09,109
它要怎么才能数到哪怕是 1 之后的数字呢

182
00:07:09,180 --> 00:07:12,409
这里有 3 个 0

183
00:07:12,680 --> 00:07:14,780
如果你将这个二进制表示的数字 "000"

184
00:07:14,979 --> 00:07:17,340
转换到我们更熟悉的一个十进制数

185
00:07:17,409 --> 00:07:18,780
结果就是 0

186
00:07:18,880 --> 00:07:19,680
好, 就说到这

187
00:07:19,780 --> 00:07:22,409
如果我们要向电脑表示数字 1

188
00:07:22,409 --> 00:07:23,979
它应该是 001

189
00:07:24,340 --> 00:07:28,580
不出意外, 和我们人类世界一致

192
00:07:28,580 --> 00:07:31,909
但是我们一般不会把开始的两个 0 写出来

194
00:07:32,310 --> 00:07:33,479
不过, 假设现在这台计算机

195
00:07:33,479 --> 00:07:34,710
想数到 2 这里去

196
00:07:34,710 --> 00:07:36,280
它并没有 2 这个数字

197
00:07:36,280 --> 00:07:39,080
所以它不得不使用一种另外的 0 和 1 的排列方式

199
00:07:39,080 --> 00:07:41,210
而结果就是 "010"

200
00:07:41,340 --> 00:07:43,380
这不是 "10" 前面有个 "0"

201
00:07:43,380 --> 00:07:45,780
实际上它是二进制下的 "010"

202
00:07:45,780 --> 00:07:47,680
如果我们想要数到大于 2 的数

203
00:07:48,109 --> 00:07:52,080
我们将需要进一步调整这些 0 和 1, 进而得到 3

205
00:07:52,180 --> 00:07:56,380
如果我们想要得到 4 或 5 或 6 或 7

206
00:07:56,380 --> 00:07:59,580
我们仿佛只需翻转这些 0 和 1

207
00:07:59,609 --> 00:08:01,940
也就是 "位 (bits)", "二进制数位 (binary digits)" 的简称

208
00:08:02,080 --> 00:08:04,140
通过这些不同的排列模式来表示

209
00:08:04,140 --> 00:08:08,479
在所谓的十进制计数系统下, 为你我这样的人类所知的不同的数字

211
00:08:08,479 --> 00:08:11,609
0 到 9 这一组数字意味着 10

212
00:08:11,609 --> 00:08:12,979
从 0 到 9, 10 位数字

213
00:08:13,210 --> 00:08:15,180
所以为什么偏偏是使用这样的一种模式

214
00:08:15,380 --> 00:08:17,340
使用这样的一些 0 和 1

215
00:08:17,340 --> 00:08:20,539
来表示这样或那样的东西

217
00:08:20,539 --> 00:08:22,979
对计算机来说非常简单?

218
00:08:22,979 --> 00:08:23,409
为什么?

219
00:08:23,409 --> 00:08:25,409
说到底，它们是由电力驱动的

220
00:08:25,409 --> 00:08:30,380
而存或不存储电能, 是件非常简单的事情

223
00:08:30,380 --> 00:08:33,480
简单到可以用两个词来描述, "开" 或 "关"

224
00:08:33,680 --> 00:08:35,610
或者说, "1" 或 "0"

225
00:08:35,710 --> 00:08:40,110
事实上, 在计算机, 手机, 或者现如今各种电子设备的内部

228
00:08:40,210 --> 00:08:41,780
均是一定数量的开关

229
00:08:41,940 --> 00:08:44,080
也被称作晶体管

230
00:08:44,080 --> 00:08:47,480
它们非常微小, 在你现今的 Mac 或 PC 还有手机里, 就有着数十亿个

233
00:08:47,480 --> 00:08:50,280
这些是可以被开启或关闭的小开关

235
00:08:50,480 --> 00:08:53,010
而按照一定的模式开启和关闭它们

236
00:08:53,010 --> 00:08:55,740
计算机可以从 0 数到 7

237
00:08:55,880 --> 00:08:57,340
甚至更高

238
00:08:57,340 --> 00:08:59,280
你可以把这些开关想象成

239
00:08:59,380 --> 00:09:00,380
这样的开关

240
00:09:00,480 --> 00:09:02,610
让我借一盏小舞台灯

241
00:09:02,610 --> 00:09:03,580
这是一个灯泡

242
00:09:03,610 --> 00:09:04,810
它目前是关闭的状态

243
00:09:04,940 --> 00:09:07,280
所以我可以把它看作是

244
00:09:07,280 --> 00:09:10,580
我笔记本电脑中的一个代表 "0" 的晶体管, 或者 "开关"

245
00:09:10,780 --> 00:09:13,310
但如果我让一些电流通过它

246
00:09:13,410 --> 00:09:15,610
那么现在我便有了一个 "1"

247
00:09:15,810 --> 00:09:17,380
那么我该怎么数到超过 1 的数呢

248
00:09:17,580 --> 00:09:18,810
显然, 这需要另一个灯泡

249
00:09:18,810 --> 00:09:20,910
让我再从这里拿一个

250
00:09:21,110 --> 00:09:23,780
如果我还是按照同样的模式将它放在这里

251
00:09:23,910 --> 00:09:25,910
我不想就这么做

252
00:09:26,110 --> 00:09:28,380
因为这是一种老式的通过数手指进行的一进制计数的方法

253
00:09:28,380 --> 00:09:29,740
就只是 "1", "2"

254
00:09:29,910 --> 00:09:33,180
I want to actually take into account the pattern of these things being on and off
我认真考虑这种将若干事物置于 "开" 或 "关" 的模式
