1
00:00:00,000 --> 00:01:17,581
[MUSIC PLAYING]

2
00:01:17,581 --> 00:01:18,501


3
00:01:18,501 --> 00:01:22,981
DAVID MALAN: 好, 欢迎来到 CS50, 这是哈佛大学针对

4
00:01:22,981 --> 00:01:25,291
计算机科学领域所包含的广泛知识,

5
00:01:25,291 --> 00:01:29,041
以及编程之艺术的导论课, 
并且是这么久以来首次重回校园,

6
00:01:29,041 --> 00:01:31,111
回到这个漂亮的桑德斯剧院.

7
00:01:31,111 --> 00:01:33,701
总之, 欢迎大家来到课堂.

8
00:01:33,701 --> 00:01:35,081
我是大卫·马兰, 又是我.

9
00:01:35,081 --> 00:01:35,847
好.

10
00:01:35,847 --> 00:01:39,249
[CHEERING AND APPLAUSE]

11
00:01:44,601 --> 00:01:46,011
我的名字是大卫·马兰.

12
00:01:46,011 --> 00:01:49,611
我本人先前也上过这门课, 但是差点没上成.

13
00:01:49,611 --> 00:01:52,821
那是大二的秋天, 我当时坐在这门课的课堂上.

14
00:01:52,821 --> 00:01:55,131
我当时是感到有些好奇, 但是怎么说,

15
00:01:55,131 --> 00:01:57,208
并不怎么觉得这是个适合我的领域.

16
00:01:57,208 --> 00:01:59,541
我确实是个喜欢用电脑的人, 但是计算机科学

17
00:01:59,541 --> 00:02:01,014
给我的感觉像是一个很宏大的东西.

18
00:02:01,014 --> 00:02:02,931
而我最终鼓起勇气上了这门课,

19
00:02:02,931 --> 00:02:05,571
则是因为当时的教授, 布莱恩·克尼汉

20
00:02:05,571 --> 00:02:08,301
允许我以不计分, 只记通过与否的方式修读这门课.

21
00:02:08,301 --> 00:02:10,191
而这正是造成一切不同的原因.

22
00:02:10,191 --> 00:02:12,681
我很快发现, 计算机科学并不只是

23
00:02:12,681 --> 00:02:15,501
有关自顾自地在电脑上进行编程和工作.

24
00:02:15,501 --> 00:02:18,091
事实上它是探讨更普遍的解决问题的方法.

25
00:02:18,091 --> 00:02:20,781
坦率来说, 当时的作业也值得一提,

26
00:02:20,781 --> 00:02:24,171
它真是很有趣来着, 也许是我 19 年来第一次这么觉得.

27
00:02:24,171 --> 00:02:26,696
还有关于这种能力,

28
00:02:26,696 --> 00:02:28,821
一路下来, 我和课上所有同学一起探索得到的这种能力,

29
00:02:28,821 --> 00:02:33,073
让我能够切实创造出一些东西,
让计算机 "活" 起来, 解决实际的问题,

30
00:02:33,073 --> 00:02:35,781
以及从某种程度上能够驾驭一些我曾经每天都在使用,

31
00:02:35,781 --> 00:02:38,961
但一直以来并不怎么清楚该如何去利用的东西,
从那时以来一直让我感到很是受用,

32
00:02:38,961 --> 00:02:40,851
诚然, 也少不了挑战性和挫败感.

33
00:02:40,851 --> 00:02:43,453
直至今日, 甚至未来很多年中,

34
00:02:43,453 --> 00:02:46,161
你总会遇到错误, 也就是编程中所说的 bug,

35
00:02:46,161 --> 00:02:47,811
它会让你发疯,

36
00:02:47,811 --> 00:02:49,311
然后你会觉得自己碰了壁.

37
00:02:49,311 --> 00:02:51,651
但其实只要给自己足够的时间, 

38
00:02:51,651 --> 00:02:53,881
或者退一步往回看看, 想休息了就休息一下,
问题便迎刃而解.

39
00:02:53,881 --> 00:02:57,141
而且我敢说, 没有什么能比得上

40
00:02:57,141 --> 00:02:58,869
当你成功让一些东西工作起来的时候的那种满足感和自豪感,

41
00:02:58,869 --> 00:03:01,161
以及在像这样的课堂上,

42
00:03:01,161 --> 00:03:04,791
当学期最终结束时, 由你自己亲手完成的最终项目.

43
00:03:04,791 --> 00:03:08,
这并不是说我当时百分之百完美地上完了这门课.

44
00:03:08,251 --> 00:03:13,461
事实上, 就在上周,
我翻看了我当时上 CS50 时用的旧活页资料夹,

45
00:03:13,461 --> 00:03:15,981
虽然都是 25 年前的了, 但是我现在还保留着它,

46
00:03:15,981 --> 00:03:20,661
接着我给这个很明显是我第一个所写并提交,

47
00:03:20,661 --> 00:03:22,971
然后很快就得了 -2 分的程序拍了张照.

48
00:03:22,971 --> 00:03:26,151
但这是一个我们未来几天内很快就会看到的程序,

49
00:03:26,151 --> 00:03:30,441
它做了些诸如打印 "Hello, CS50" 这样很简单的事情,

50
00:03:30,441 --> 00:03:31,109
在本例中, (就是打印) 到 (计算机) 屏幕上.

51
00:03:31,109 --> 00:03:32,901
公平地讲, 我当时确实没有完全按照指导去做,

52
00:03:32,901 --> 00:03:35,181
所以我才丢了那两分.

53
00:03:35,181 --> 00:03:38,503
但如果你就单看这个,
特别是如果你以前从未编程过,

54
00:03:38,503 --> 00:03:40,461
尽管你或许听说过编程语言,

55
00:03:40,461 --> 00:03:42,419
但你从来没有键入过这样的东西,

56
00:03:42,419 --> 00:03:44,181
毫无疑问, 这对你来说是晦涩难懂的.

57
00:03:44,181 --> 00:03:46,221
但坦白说, 它并不像人类语言那样,

58
00:03:46,221 --> 00:03:50,181
人类语言复杂得多, 有着多得多的词汇,

59
00:03:50,181 --> 00:03:54,321
以及多得多的语法规则. 
但编程这个东西, 一旦你开始体会到

60
00:03:54,321 --> 00:03:57,434
它究竟是什么, 它是如何工作的,
以及这些各式各样的编程语言究竟为何之后,

61
00:03:57,434 --> 00:03:59,601
接下来再自学其它语言将会是那么容易,

62
00:03:59,601 --> 00:04:01,701
上几个月这样的课之后你就能发现.

63
00:04:01,701 --> 00:04:05,431
在你未来几年的课程中或许就会遇到它们.

64
00:04:05,431 --> 00:04:08,751
所以, 在这门课最重要的,

65
00:04:08,751 --> 00:04:11,391
不是你最终达到的水平相对于你的同学怎么样,

66
00:04:11,391 --> 00:04:14,601
而是相比于你自己刚开始时的情况如何.

67
00:04:14,601 --> 00:04:16,081
实际上, 你们今天就要开始了.

68
00:04:16,081 --> 00:04:19,611
在这门课中, 最终下来, 唯一有意义的经历, 是你自己的经历.

69
00:04:19,611 --> 00:04:21,741
所以不妨先想想你今天是怎样的一个情况

70
00:04:21,741 --> 00:04:24,231
不妨想想, 这些东西几秒前看起来

71
00:04:24,231 --> 00:04:25,551
还是那么的晦涩难懂.

72
00:04:25,551 --> 00:04:28,881
但是请放心, 几个月后, 所有这些,

73
00:04:28,881 --> 00:04:31,109
将尽在你的掌握之中.

74
00:04:31,109 --> 00:04:34,401
假如你觉得, 自己前面, 左面, 

75
00:04:34,401 --> 00:04:38,121
右面, 后面的某人, 知道的要比你多,
其实从数据上来看, 并非如此.

76
00:04:38,121 --> 00:04:42,801
CS50 课上 2/3 的学生以前从未上过
计算机科学的课程, 也就是说


77
00:04:42,801 --> 00:04:47,431
整个学期下来, 有很多人都和你一样.

78
00:04:47,431 --> 00:04:49,521
那么什么是计算机科学呢?

79
00:04:49,521 --> 00:04:51,141
我个人认为它就是在研究如何解决问题.

80
00:04:51,141 --> 00:04:53,421
这就很好, 因为解决问题几乎是一件

81
00:04:53,421 --> 00:04:55,731
我们无时无刻都在做的事情.

82
00:04:55,731 --> 00:04:58,534
而修读计算机科学课, 学习如何编程,

83
00:04:58,534 --> 00:05:00,201
我觉得能一定程度上帮助你理清思绪.

84
00:05:00,201 --> 00:05:03,741
它帮助你学会如何更有条理地, 更细致地,

85
00:05:03,741 --> 00:05:05,331
更正确地, 更精确地思考.

86
00:05:05,331 --> 00:05:07,164
因为老实说, 计算机不可会执行你想要它做的事,

87
00:05:07,164 --> 00:05:10,371
除非你是正确的, 精确的, 有条理的.

88
00:05:10,371 --> 00:05:12,596
可见, 只是学着像计算科学家

89
00:05:12,596 --> 00:05:15,471
和程序员一样思考, 就有这么一些附带的好处.

90
00:05:15,471 --> 00:05:18,261
而且开始这样做并不需要很多.

91
00:05:18,261 --> 00:05:21,921
例如，这可能是个最简单的能描绘计算机科学的图,

92
00:05:21,921 --> 00:05:23,841
但事实上任何解决问题的普遍方法也是如此.

93
00:05:23,841 --> 00:05:27,171
问题无非是关乎接受输入,
例如一个你想解决的问题,

94
00:05:27,171 --> 00:05:29,061
你想要得到解，也就是

95
00:05:29,061 --> 00:05:29,751
输出 (output).

96
00:05:29,751 --> 00:05:32,451
所以一些有趣的事情需要在这里发生

97
00:05:32,451 --> 00:05:35,941
以及在这里 (头脑中), 当你试图从这些输入得到输出时.

98
00:05:35,941 --> 00:05:38,511
而在计算机这个领域,

99
00:05:38,511 --> 00:05:42,381
我们需要事先决定好
要如何表示这些输入和输出.

100
00:05:42,381 --> 00:05:46,424
不管我们要使用的 (这些设备)
是 Mac 还是 PC 还是手机还是别的什么,

101
00:05:46,424 --> 00:05:49,341
我们要决定使用某种共同的语言,

102
00:05:49,341 --> 00:05:51,541
当然, 也不管我们讲的是什么人类语言.

103
00:05:51,541 --> 00:05:55,251
你可能已经知道, 计算机只倾向于也就是我们说的

104
00:05:55,251 --> 00:05:59,441
说哪种语言呢? 也就是我们说的

105
00:05:59,441 --> 00:06:01,931
汇编语言,
但是要是你说 "二进制", 也没问题

106
00:06:01,931 --> 00:06:05,021
在 "二进制 (binary)" 中,
"二 (bi)" 意味着在计算机的世界里

107
00:06:05,021 --> 00:06:08,681
只有 0 和 1 两个数位可供使用.

108
00:06:08,681 --> 00:06:12,761
诚然, 我们人类能使用的数字比这更多,

109
00:06:12,761 --> 00:06:13,391
至少不只是 0 和 1.

110
00:06:13,391 --> 00:06:15,821
但是计算机却只有 0 和 1.

111
00:06:15,821 --> 00:06:18,041
然而不知何故, 它们却可以做到非常多的功能.

112
00:06:18,041 --> 00:06:20,411
它们可以处理 Excel 表格中的数字, 发送文本讯息,

113
00:06:20,411 --> 00:06:23,781
也可以生成图像,
甚至是艺术作品和电影等等.

114
00:06:23,781 --> 00:06:27,491
所以你是如何从一堆 0 和 1 这样简单的东西,

115
00:06:27,491 --> 00:06:29,621
得到我们现今在掌中、笔记本电脑和台式机上

116
00:06:29,621 --> 00:06:31,571
所做的一切的呢?

117
00:06:31,571 --> 00:06:34,271
我们可以从很简单的地方开始.

118
00:06:34,271 --> 00:06:38,171
如果一台计算机想要进行像计数这样简单的事情,

119
00:06:38,171 --> 00:06:38,891
它可以怎么做呢?

120
00:06:38,891 --> 00:06:41,891
在我们人类的世界中, 我们可以像

121
00:06:41,891 --> 00:06:46,479
"1, 2, 3, 4, 5" 这样数,
使用所谓的 "一进制计数法", 字面上来说就是,

122
00:06:46,479 --> 00:06:49,271
比方说, 现在我要统计出勤情况,
你手上的每个手指,

123
00:06:49,271 --> 00:06:51,221
都是一个数字, 代表房间里的一个人.

124
00:06:51,221 --> 00:06:55,301
我们人类通常会直接去数 "1, 2, 3, 4, 5, 6",

125
00:06:55,301 --> 00:06:58,181
然后我们将会超出这 (一只手所能代表的) 5 个数,

126
00:06:58,181 --> 00:06:59,651
并使用从 0 到 9 这些数字, 数到很远的地方.

127
00:06:59,651 --> 00:07:02,571
但是计算机却只有 0 和 1.

128
00:07:02,571 --> 00:07:05,891
所以如果一台计算机只能使用二进制的 0 和 1,

129
00:07:05,891 --> 00:07:08,881
它要怎么才能数到哪怕是 1 之后的数字呢?

130
00:07:08,881 --> 00:07:11,441
这里有 3 个 0.

131
00:07:11,441 --> 00:07:14,951
如果你将这个二进制表示的数字 "000",

132
00:07:14,951 --> 00:07:18,851
转换到我们更熟悉的一个十进制数去,
结果就是 0.

133
00:07:18,851 --> 00:07:19,721
好, 就说到这.

134
00:07:19,721 --> 00:07:22,571
如果我们要向电脑表示数字 1,

135
00:07:22,571 --> 00:07:25,631
它应该是 "001", 结果不出意外,

136
00:07:25,631 --> 00:07:28,691
这和我们人类世界一致,

137
00:07:28,691 --> 00:07:32,201
但是我们一般不会把开始的两个 0 写出来.

138
00:07:32,201 --> 00:07:34,871
不过, 假设现在这台计算机, 想数到 2 这里去,

139
00:07:34,871 --> 00:07:36,401
它并没有 2 这个数字.

140
00:07:36,401 --> 00:07:39,131
所以它不得不使用一种另外的 0 和 1 的排列方式.

141
00:07:39,131 --> 00:07:41,321
而结果就是 "010".

142
00:07:41,321 --> 00:07:43,511
这不是 "10" 前面有个 "0".

143
00:07:43,511 --> 00:07:45,981
实际上它是二进制下的 "010".

144
00:07:45,981 --> 00:07:48,101
如果我们想要数到大于 2 的数,

145
00:07:48,101 --> 00:07:52,241
我们将需要进一步调整这些 0 和 1, 进而得到 3.

146
00:07:52,241 --> 00:07:56,711
如果我们接下来想要得到 4 或 5 或 6 或 7,

147
00:07:56,711 --> 00:07:59,621
我们仿佛只需翻转这些 0 和 1, 也就是

148
00:07:59,621 --> 00:08:04,108
"位 (bits)", "二进制数位 (binary digits)" 的简称
这些二进制数位, 通过不同的排列模式, 表示出了

149
00:08:04,108 --> 00:08:06,191
为你我这样的人类所知的不同的数字

150
00:08:06,191 --> 00:08:09,431
当然, 是在十进制 (decimal) 下, 使用数字 0 到 9,

151
00:08:09,431 --> 00:08:13,091
"dec" 意味着 10, 10 个数位, 对应从 0 到 9 这些数字.

152
00:08:13,091 --> 00:08:15,461
所以为什么偏偏是使用这样的一种模式?

153
00:08:15,461 --> 00:08:17,381
为什么使用这样的一些 0 和 1

154
00:08:17,381 --> 00:08:20,711
来表示这样或那样的东西

155
00:08:20,711 --> 00:08:23,061
对计算机来说非常简单?

156
00:08:23,061 --> 00:08:23,561
为什么呢?

157
00:08:23,561 --> 00:08:25,811
说到底，它们是由电力驱动的.

158
00:08:25,811 --> 00:08:28,781
而存或不存储电能,

159
00:08:28,781 --> 00:08:30,491
是件非常简单的事情.

160
00:08:30,491 --> 00:08:33,611
简单到可以用两个词来描述, "开 (on)" 或 "关 (off)".

161
00:08:33,611 --> 00:08:35,811
或者说, "1" 或 "0".

162
00:08:35,811 --> 00:08:38,521
事实上, 在计算机, 手机,

163
00:08:38,521 --> 00:08:40,271
或者现如今各种电子设备的内部,

164
00:08:40,271 --> 00:08:43,463
均是一定数量的开关,
也被称作晶体管.

165
00:08:43,463 --> 00:08:44,171
它们非常微小.

166
00:08:44,171 --> 00:08:47,553
在你现今的 Mac 或 PC 还有手机里, 就有着数十亿个.

167
00:08:47,553 --> 00:08:50,511
这些是可以被开启或关闭的小开关.

168
00:08:50,511 --> 00:08:53,171
而按照一定的模式开启和关闭它们,

169
00:08:53,171 --> 00:08:56,974
计算机可以从 0 数到 7, 甚至更高.

170
00:08:56,974 --> 00:08:59,891
你可以把这些开关想象成

171
00:08:59,891 --> 00:09:00,391
这样的开关.

172
00:09:00,391 --> 00:09:02,683
让我借用一盏这里的小舞台灯.

173
00:09:02,683 --> 00:09:03,671
这是一个灯泡.

174
00:09:03,671 --> 00:09:04,961
它目前是关闭的状态.

175
00:09:04,961 --> 00:09:07,391
所以我可以把它看作是,

176
00:09:07,391 --> 00:09:10,811
我笔记本电脑中的一个
代表 "0" 的晶体管, 或者 "开关".

177
00:09:10,811 --> 00:09:15,821
但如果我让一些电流通过它,
那么现在我便有了一个 "1".

178
00:09:15,821 --> 00:09:17,431
那么我该怎么数到超过 1 的数呢?

179
00:09:17,431 --> 00:09:19,041
显然, 我需要另一个灯泡.

180
00:09:19,041 --> 00:09:21,231
让我再从这里拿一个.

181
00:09:21,231 --> 00:09:26,051
我可以依然按照同样的方式就将它放在这里,
但我不想就这么做.

182
00:09:26,051 --> 00:09:29,841
因为这是一种老式的, 类似于你数手指一样的, 使用一进制计数的方法,
就只是 "1", "2".

183
00:09:29,841 --> 00:09:31,841
我想认真考虑这种

184
00:09:31,841 --> 00:09:33,381
将若干事物置于 "开" 或 "关" 的模式.
