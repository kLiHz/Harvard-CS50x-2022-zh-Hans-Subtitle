1
00:01:17,600 --> 00:01:20,130
好, 欢迎来到 CS50

2
00:01:20,130 --> 00:01:23,970
这是哈佛大学针对计算机科学领域所包含的广泛知识

4
00:01:23,970 --> 00:01:25,300
以及编程之艺术的入门介绍课程

5
00:01:25,300 --> 00:01:29,800
经过了这么长时间, 这是我们首次重回校园, 回到这个漂亮的桑德斯剧院

7
00:01:29,900 --> 00:01:32,330
总之, 欢迎大家来到这个课堂

8
00:01:32,370 --> 00:01:34,530
我是大卫·马兰, 又一次来上这门课

9
00:01:43,400 --> 00:01:44,600
我的名字是大卫·马兰

10
00:01:44,600 --> 00:01:47,070
我本人一段时间之前也上过这门课

11
00:01:47,070 --> 00:01:48,470
但是差点

12
00:01:48,570 --> 00:01:49,870
那是大二的秋天

13
00:01:49,870 --> 00:01:51,470
我当时只是在旁听这门课

14
00:01:51,470 --> 00:01:52,700
我只是对这门课感到有些好奇

15
00:01:53,270 --> 00:01:56,000
但是并不觉得这个领域很适合我

16
00:01:56,000 --> 00:01:57,470
我确实是个喜欢用电脑的人

17
00:01:57,470 --> 00:01:59,500
但是计算机科学给我的感觉像是一个很宏大的东西

18
00:01:59,670 --> 00:02:01,200
而我最终鼓起勇气选了这门课

19
00:02:01,200 --> 00:02:03,300
则是因为当时的教授

20
00:02:03,300 --> 00:02:04,270
布莱恩·克尼汉

21
00:02:04,330 --> 00:02:06,930
允许我以不计分, 只记通过与否的方式修读这门课

23
00:02:06,930 --> 00:02:08,870
而这正是造成一切不同的原因

24
00:02:08,900 --> 00:02:10,199
我很快发现

25
00:02:10,199 --> 00:02:14,130
计算机科学并不只是有关自顾自地在电脑上进行编程和工作

27
00:02:14,130 --> 00:02:16,600
更普遍地说, 它其实更注重于问题的解决

28
00:02:16,730 --> 00:02:20,600
坦率来说, 当时的作业真是很有趣来着

30
00:02:20,600 --> 00:02:21,770
也许是我 19 年来第一次这么觉得

31
00:02:21,770 --> 00:02:27,500
还有一路下来, 我和课上所有同学一起探索得到的这种能力

34
00:02:27,500 --> 00:02:31,670
让我能够切实创造出一些东西, 让计算机 "活" 起来, 解决实际的问题

36
00:02:31,870 --> 00:02:34,470
以及从某种程度上能够驾驭一些我曾经每天都在使用

38
00:02:34,470 --> 00:02:35,800
但一直以来并不怎么清楚该如何去利用的东西

39
00:02:35,930 --> 00:02:37,570
收获这种能力让我感到很是受用

40
00:02:37,600 --> 00:02:42,300
诚然, 一路走来, 也少不了挑战性和挫败感, 未来很多年也会如此

42
00:02:42,330 --> 00:02:43,800
你会遇到错误

43
00:02:43,800 --> 00:02:45,370
也就是编程中所说的 bug

44
00:02:45,370 --> 00:02:46,470
它会让你发疯

45
00:02:46,470 --> 00:02:47,870
然后你觉得自己碰了壁

46
00:02:48,100 --> 00:02:51,100
但其实只要给自己足够的时间, 或者退一步往回看看

48
00:02:51,100 --> 00:02:52,470
然后想休息了就休息一下, 问题便迎刃而解

49
00:02:52,500 --> 00:02:54,100
而且我敢说, 没有什么能比得上

50
00:02:54,100 --> 00:02:57,970
当你成功让一些东西工作起来的时候的那种满足感和自豪感

52
00:02:57,970 --> 00:03:00,870
以及在像这样的课堂上, 当学期最终结束时

53
00:03:00,970 --> 00:03:03,500
由你自己亲手完成的最终项目

54
00:03:03,600 --> 00:03:06,800
这并不是说我当时百分之百完美地上完了这门课

55
00:03:06,800 --> 00:03:09,300
事实上就在上周

57
00:03:09,300 --> 00:03:11,600
我翻看了我当时上 CS50 时用的旧活页资料夹

58
00:03:11,600 --> 00:03:13,870
都是 25 年前的了, 但是我现在还保留着它

59
00:03:13,900 --> 00:03:19,300
然后给这个很明显是我第一个所写并提交的

62
00:03:19,370 --> 00:03:21,570
然后很快得了 -2 分的程序拍了张照

63
00:03:21,770 --> 00:03:24,500
但这是一个我们未来几天内很快就会看到的程序

65
00:03:24,500 --> 00:03:28,400
它做了些诸如打印 "Hello, CS50" 这样很简单的事情

67
00:03:28,570 --> 00:03:29,900
在本例中, (就是打印) 到 (计算机) 屏幕上

68
00:03:29,900 --> 00:03:32,370
公平地讲, 我当时确实没有完全按照指导去做

70
00:03:32,370 --> 00:03:33,870
所以我才丢了那两分

71
00:03:33,870 --> 00:03:35,100
但如果你就单看这个

72
00:03:35,370 --> 00:03:37,370
特别是如果你以前从未编程过

73
00:03:37,370 --> 00:03:39,170
你或许听说过编程语言

74
00:03:39,170 --> 00:03:40,900
但你从来没有键入过这样的东西

75
00:03:40,970 --> 00:03:42,900
毫无疑问, 这看起来晦涩难懂

76
00:03:43,100 --> 00:03:45,770
但坦白说, 它并不像人类语言那样

77
00:03:45,870 --> 00:03:50,470
人类语言复杂得多, 有着多得多的词汇, 以及多得多的语法规则

79
00:03:50,600 --> 00:03:53,900
编程这个东西, 一旦你开始理解它究竟是什么, 它是如何工作的

81
00:03:53,900 --> 00:03:55,330
以及这些各式各样的编程语言究竟为何之后

82
00:03:55,330 --> 00:04:01,200
接下来再自学其它语言将会是那么容易, 上几个月这样的课之后你就能发现

86
00:04:01,200 --> 00:04:03,930
在你未来几年的课程中或许就会遇到它们

87
00:04:04,300 --> 00:04:07,400
所以, 在这门课最重要的

88
00:04:07,400 --> 00:04:10,130
不是你最终达到的水平相对于你的同学怎么样

90
00:04:10,170 --> 00:04:12,100
而是相比于你自己刚开始时的情况如何

91
00:04:12,400 --> 00:04:14,600
实际上你们从今天就要开始了

92
00:04:14,600 --> 00:04:18,200
在这门课中, 最终下来, 唯一有意义的经历, 是你自己的经历

94
00:04:18,300 --> 00:04:20,329
所以不妨先想想你今天是怎样的一个情况

95
00:04:20,470 --> 00:04:24,200
不妨想想, 这些东西几秒前看起来还是那么晦涩难懂

98
00:04:24,300 --> 00:04:30,100
而几个月后, 所有这些将尽在你的掌握之中, 是不是感到很欣慰

101
00:04:30,100 --> 00:04:31,370
你当然可能觉得

102
00:04:31,370 --> 00:04:34,070
自己前面, 左面, 右面, 后面的某人

104
00:04:34,070 --> 00:04:35,000
知道的比你多

105
00:04:35,200 --> 00:04:36,730
其实从数据上来看, 并非如此

106
00:04:36,930 --> 00:04:40,770
CS50 课上 2/3 的学生以前从未上过计算机科学的课程

107
00:04:40,770 --> 00:04:45,600
也就是说整个学期下来, 有很多人都和你一样

109
00:04:46,270 --> 00:04:48,170
那么什么是计算机科学呢?

110
00:04:48,170 --> 00:04:49,770
我个人认为它就是在研究如何解决问题

111
00:04:49,770 --> 00:04:54,600
这样就带来一个好处, 因为解决问题几乎是一件我们无时无刻都在做的事情

113
00:04:54,700 --> 00:04:57,100
但是修读计算机科学课, 学习如何编程,

114
00:04:57,100 --> 00:04:58,800
我觉得能一定程度上帮助你理清思绪

116
00:04:58,800 --> 00:05:01,270
它帮助你学会, 如何更有条理地

117
00:05:01,400 --> 00:05:03,930
更细致, 更正确, 更精确地思考

118
00:05:03,930 --> 00:05:04,500
因为老实说

119
00:05:04,500 --> 00:05:06,000
计算机不会执行你想要它做的事

120
00:05:06,000 --> 00:05:09,000
除非你是正确的, 精确的, 有条理的

121
00:05:09,100 --> 00:05:10,000
可见

122
00:05:10,000 --> 00:05:12,270
只是学着像计算科学家和程序员一样思考

124
00:05:12,270 --> 00:05:14,100
就有这么一些附带的好处

126
00:05:14,300 --> 00:05:16,970
而且开始这样做并不需要很多

127
00:05:17,000 --> 00:05:20,600
例如，这可能是个最简单的能描绘计算机科学的图

129
00:05:20,600 --> 00:05:22,530
但事实上任何解决问题的方法也大多如此

130
00:05:22,530 --> 00:05:24,470
问题无非是关乎接受输入

131
00:05:24,470 --> 00:05:25,870
例如一个你想解决的问题

132
00:05:25,900 --> 00:05:28,470
你想要得到解，也就是输出 (output)

133
00:05:28,470 --> 00:05:30,800
所以一些有趣的事情需要发生在这里

134
00:05:30,800 --> 00:05:31,870
以及在这里 (头脑中)

135
00:05:31,900 --> 00:05:34,300
当你试图从这些输入得到输出时

136
00:05:34,730 --> 00:05:37,170
而在计算机这个领域

137
00:05:37,200 --> 00:05:38,300
我们需要事先决定好

138
00:05:38,300 --> 00:05:41,100
要如何表示这些输入和输出

139
00:05:41,100 --> 00:05:45,330
我们要使用一些共同的语言

141
00:05:45,330 --> 00:05:46,800
不管 (这些设备) 是 Mac 还是 PC 还是手机还是别的什么

142
00:05:46,900 --> 00:05:50,130
当然, 也不管我们讲的是什么人类语言

144
00:05:50,200 --> 00:05:51,870
你可能已经知道

145
00:05:52,270 --> 00:05:54,970
计算机只倾向于说哪种语言呢

146
00:05:55,000 --> 00:05:55,970
也就是我们说的

147
00:05:58,100 --> 00:05:58,730
汇编语言

148
00:05:58,730 --> 00:06:01,400
但是其实你说 "二进制" 也没问题

149
00:06:01,400 --> 00:06:04,070
在 "二进制 (binary)" 中, "二 (bi)" 意味着在计算机的世界里

150
00:06:04,170 --> 00:06:06,170
只有 0 和 1 两个数位可供使用

151
00:06:06,300 --> 00:06:10,570
诚然, 我们人类能使用的数字比这更多

152
00:06:10,570 --> 00:06:12,070
至少不只是 0 和 1

153
00:06:12,070 --> 00:06:14,470
但是计算机只有 0 和 1

154
00:06:14,470 --> 00:06:15,500
然而不知何故

155
00:06:15,700 --> 00:06:16,700
它们却可以做到非常多的功能

156
00:06:16,700 --> 00:06:19,100
它们可以处理数字, Excel 表格, 还有文本讯息

157
00:06:19,100 --> 00:06:20,170
也可以生成图像

158
00:06:20,330 --> 00:06:22,270
甚至是艺术作品和电影等等

159
00:06:22,500 --> 00:06:26,200
所以你是如何从一堆 0 和 1 这样简单的东西

161
00:06:26,200 --> 00:06:30,330
得到我们现今在掌中、笔记本电脑和台式机上所做的一切

163
00:06:30,470 --> 00:06:32,970
事实证明，我们可以很简单地开始

164
00:06:33,000 --> 00:06:36,500
如果一台计算机想要做像计数一样简单的事情

166
00:06:36,770 --> 00:06:39,130
它可以怎么做呢? 在我们人类的世界中

167
00:06:39,130 --> 00:06:42,500
我们可以像 "1 2 3 4 5" 这样数

168
00:06:42,530 --> 00:06:44,330
使用所谓的 "一进制计数法"

169
00:06:44,330 --> 00:06:45,800
字面上来说就是, 你手上的每个手指

170
00:06:45,800 --> 00:06:47,900
都是一个数字, 代表房间里的一个人

171
00:06:47,900 --> 00:06:49,870
比方说, 现在我要统计出勤情况

172
00:06:49,970 --> 00:06:52,200
我们人类通常会直接去数

173
00:06:52,470 --> 00:06:53,970
1 2 3 4 5 6

174
00:06:53,970 --> 00:06:56,870
然后我们将会超出这 (一只手所能代表的) 5 个数

176
00:06:56,870 --> 00:06:58,400
并使用从 0 到 9 这些数字, 数到很远的地方

177
00:06:58,400 --> 00:07:01,070
但是计算机却只有 0 和 1

178
00:07:01,330 --> 00:07:04,600
所以如果一台计算机只能使用二进制的 0 和 1

180
00:07:04,600 --> 00:07:07,900
它要怎么才能数到哪怕是 1 之后的数字呢

182
00:07:07,970 --> 00:07:11,200
这里有 3 个 0

183
00:07:11,470 --> 00:07:13,570
如果你将这个二进制表示的数字 "000"

184
00:07:13,770 --> 00:07:16,130
转换到我们更熟悉的一个十进制数

185
00:07:16,200 --> 00:07:17,570
结果就是 0

186
00:07:17,670 --> 00:07:18,470
好, 就说到这

187
00:07:18,570 --> 00:07:21,200
如果我们要向电脑表示数字 1

188
00:07:21,200 --> 00:07:22,770
它应该是 001

189
00:07:23,130 --> 00:07:27,370
不出意外, 和我们人类世界一致

192
00:07:27,370 --> 00:07:30,700
但是我们一般不会把开始的两个 0 写出来

194
00:07:31,100 --> 00:07:32,270
不过, 假设现在这台计算机

195
00:07:32,270 --> 00:07:33,500
想数到 2 这里去

196
00:07:33,500 --> 00:07:35,070
它并没有 2 这个数字

197
00:07:35,070 --> 00:07:37,870
所以它不得不使用一种另外的 0 和 1 的排列方式

199
00:07:37,870 --> 00:07:40,000
而结果就是 "010"

200
00:07:40,130 --> 00:07:42,170
这不是 "10" 前面有个 "0"

201
00:07:42,170 --> 00:07:44,570
实际上它是二进制下的 "010"

202
00:07:44,570 --> 00:07:46,470
如果我们想要数到大于 2 的数

203
00:07:46,900 --> 00:07:50,870
我们将需要进一步调整这些 0 和 1, 进而得到 3

205
00:07:50,970 --> 00:07:55,170
如果我们想要得到 4 或 5 或 6 或 7

206
00:07:55,170 --> 00:07:58,370
我们仿佛只需翻转这些 0 和 1

207
00:07:58,400 --> 00:08:00,730
也就是 "位 (bits)", "二进制数位 (binary digits)" 的简称

208
00:08:00,870 --> 00:08:02,930
通过这些不同的排列模式来表示

209
00:08:02,930 --> 00:08:07,270
在所谓的十进制计数系统下, 为你我这样的人类所知的不同的数字

211
00:08:07,270 --> 00:08:10,400
0 到 9 这一组数字意味着 10

212
00:08:10,400 --> 00:08:11,770
从 0 到 9, 10 位数字

213
00:08:12,000 --> 00:08:13,970
所以为什么偏偏是使用这样的一种模式

214
00:08:14,170 --> 00:08:16,130
使用这样的一些 0 和 1

215
00:08:16,130 --> 00:08:19,330
来表示这样或那样的东西

217
00:08:19,330 --> 00:08:21,770
对计算机来说非常简单?

218
00:08:21,770 --> 00:08:22,200
为什么?

219
00:08:22,200 --> 00:08:24,200
说到底，它们是由电力驱动的

220
00:08:24,200 --> 00:08:29,170
而存或不存储电能, 是件非常简单的事情

223
00:08:29,170 --> 00:08:32,270
简单到可以用两个词来描述, "开" 或 "关"

224
00:08:32,470 --> 00:08:34,400
或者说, "1" 或 "0"

225
00:08:34,500 --> 00:08:38,900
事实上, 在计算机, 手机, 或者现如今各种电子设备的内部

228
00:08:39,000 --> 00:08:40,570
均是一定数量的开关

229
00:08:40,730 --> 00:08:42,870
也被称作晶体管

230
00:08:42,870 --> 00:08:46,270
它们非常微小, 在你现今的 Mac 或 PC 还有手机里, 就有着数十亿个

233
00:08:46,270 --> 00:08:49,070
这些是可以被开启或关闭的小开关

235
00:08:49,270 --> 00:08:51,800
而按照一定的模式开启和关闭它们

236
00:08:51,800 --> 00:08:54,530
计算机可以从 0 数到 7

237
00:08:54,670 --> 00:08:56,130
甚至更高

238
00:08:56,130 --> 00:08:58,070
你可以把这些开关想象成

239
00:08:58,170 --> 00:08:59,170
这样的开关

240
00:08:59,270 --> 00:09:01,400
让我借一盏小舞台灯

241
00:09:01,400 --> 00:09:02,370
这是一个灯泡

242
00:09:02,400 --> 00:09:03,600
它目前是关闭的状态

243
00:09:03,730 --> 00:09:06,070
所以我可以把它看作是

244
00:09:06,070 --> 00:09:09,370
我笔记本电脑中的一个代表 "0" 的晶体管, 或者 "开关"

245
00:09:09,570 --> 00:09:12,100
但如果我让一些电流通过它

246
00:09:12,200 --> 00:09:14,400
那么现在我便有了一个 "1"

247
00:09:14,600 --> 00:09:16,170
那么我该怎么数到超过 1 的数呢

248
00:09:16,370 --> 00:09:17,600
显然, 这需要另一个灯泡

249
00:09:17,600 --> 00:09:19,700
让我再从这里拿一个

250
00:09:19,900 --> 00:09:22,570
如果我还是按照同样的模式将它放在这里

251
00:09:22,700 --> 00:09:24,700
我不想就这么做

252
00:09:24,900 --> 00:09:27,170
因为这是一种老式的通过数手指进行的一进制计数的方法

253
00:09:27,170 --> 00:09:28,530
就只是 "1", "2"

254
00:09:28,700 --> 00:09:31,970
I want to actually take into account the pattern of these things being on and off
我认真考虑这种将若干事物置于 "开" 或 "关" 的模式
